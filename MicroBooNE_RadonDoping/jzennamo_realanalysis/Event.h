//////////////////////////////////////////////////////////
// This class has been automatically generated on
// Wed Jun 30 16:03:41 2021 by ROOT version 6.12/06
// from TTree Event/Event Tree
// found on file: /pnfs/uboone/scratch/users/ilepetic/bipogrid/v08_00_00_55/ilepetic_newoverlay_bipofinder3/newoverlays_clusters.root
//////////////////////////////////////////////////////////

#ifndef Event_h
#define Event_h

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>

// Header file for the classes stored in the TTree if any.
#include "vector"
#include "vector"
#include "vector"
#include "vector"
#include "vector"
#include "vector"
#include "vector"

class Event {
public :
   TTree          *fChain;   //!pointer to the analyzed TTree or TChain
   Int_t           fCurrent; //!current Tree number in a TChain

// Fixed size dimensions of array or collections stored in the TTree if any.

   // Declaration of leaf types
   UInt_t          event;
   UInt_t          run;
   UInt_t          subrun;
   vector<int>     *TrackId;
   vector<int>     *Mother;
   vector<int>     *NumberDaughters;
   vector<int>     *pdg;
   vector<double>  *Eng;
   vector<double>  *StartPointx;
   vector<double>  *StartPointy;
   vector<double>  *StartPointz;
   vector<double>  *EndPointx;
   vector<double>  *EndPointy;
   vector<double>  *EndPointz;
   vector<double>  *TrueWire;
   vector<double>  *TrueTime;
   vector<double>  *Time;
   vector<double>  *Px;
   vector<double>  *Py;
   vector<double>  *Pz;
   vector<double>  *AlphaTruthWire;
   vector<double>  *AlphaTruthTime;
   vector<double>  *AlphaTruthX;
   vector<double>  *AlphaTruthY;
   vector<double>  *AlphaTruthZ;
   vector<double>  *AlphaTruthIntegral;
   vector<double>  *AlphaTruthRMS;
   vector<double>  *BetaTruthWire;
   vector<double>  *BetaTruthTime;
   vector<double>  *BetaTruthX;
   vector<double>  *BetaTruthY;
   vector<double>  *BetaTruthZ;
   vector<double>  *BetaTruthIntegral;
   vector<double>  *BetaTruthRMS;
   vector<double>  *BetaTruthE;
   vector<double>  *BetaTruthEndE;
   vector<string>  *process;
   vector<int>     *NewNumberHits;
   vector<int>     *ClusterPDG;
   vector<bool>    *ClusterPrimary;
   vector<vector<double> > *ClusterHitRMS;
   vector<vector<double> > *ClusterHitIntegral;
   vector<vector<double> > *ClusterHitGOF;
   vector<vector<double> > *ClusterHitTime;
   UInt_t          reco_num_hits;
   vector<float>   *reco_hit_charge;
   vector<float>   *reco_hit_amplitude;
   vector<float>   *reco_hit_time;
   vector<unsigned int> *reco_hit_plane;
   vector<unsigned int> *reco_hit_wire;
   vector<float>   *cluster_start_wire;
   vector<float>   *cluster_end_wire;
   vector<double>  *cluster_x;
   vector<double>  *cluster_z;
   vector<float>   *cluster_time;
   vector<double>  *cluster_integral;
   vector<unsigned int> *cluster_nhits;
   vector<int>     *cluster_plane;
   Double_t        TotalSimChanCharge_plane0;
   Double_t        TotalSimChanCharge_plane1;
   Double_t        TotalSimChanCharge_plane2;
   Double_t        matchedSimChanCharge_plane0;
   Double_t        matchedSimChanCharge_plane1;
   Double_t        matchedSimChanCharge_plane2;
   vector<float>   *IDEx;
   vector<float>   *IDEy;
   vector<float>   *IDEz;
   vector<float>   *IDEelectrons;
   vector<float>   *IDEenergy;
   vector<int>     *IDEtrackid;

   // List of branches
   TBranch        *b_event;   //!
   TBranch        *b_run;   //!
   TBranch        *b_subrun;   //!
   TBranch        *b_TrackId;   //!
   TBranch        *b_Mother;   //!
   TBranch        *b_NumberDaughters;   //!
   TBranch        *b_pdg;   //!
   TBranch        *b_Eng;   //!
   TBranch        *b_StartPointx;   //!
   TBranch        *b_StartPointy;   //!
   TBranch        *b_StartPointz;   //!
   TBranch        *b_EndPointx;   //!
   TBranch        *b_EndPointy;   //!
   TBranch        *b_EndPointz;   //!
   TBranch        *b_TrueWire;   //!
   TBranch        *b_TrueTime;   //!
   TBranch        *b_Time;   //!
   TBranch        *b_Px;   //!
   TBranch        *b_Py;   //!
   TBranch        *b_Pz;   //!
   TBranch        *b_AlphaTruthWire;   //!
   TBranch        *b_AlphaTruthTime;   //!
   TBranch        *b_AlphaTruthX;   //!
   TBranch        *b_AlphaTruthY;   //!
   TBranch        *b_AlphaTruthZ;   //!
   TBranch        *b_AlphaTruthIntegral;   //!
   TBranch        *b_AlphaTruthRMS;   //!
   TBranch        *b_BetaTruthWire;   //!
   TBranch        *b_BetaTruthTime;   //!
   TBranch        *b_BetaTruthX;   //!
   TBranch        *b_BetaTruthY;   //!
   TBranch        *b_BetaTruthZ;   //!
   TBranch        *b_BetaTruthIntegral;   //!
   TBranch        *b_BetaTruthRMS;   //!
   TBranch        *b_BetaTruthE;   //!
   TBranch        *b_BetaTruthEndE;   //!
   TBranch        *b_process;   //!
   TBranch        *b_NewNumberHits;   //!
   TBranch        *b_ClusterPDG;   //!
   TBranch        *b_ClusterPrimary;   //!
   TBranch        *b_ClusterHitRMS;   //!
   TBranch        *b_ClusterHitIntegral;   //!
   TBranch        *b_ClusterHitGOF;   //!
   TBranch        *b_ClusterHitTime;   //!
   TBranch        *b_reco_num_hits;   //!
   TBranch        *b_reco_hit_charge;   //!
   TBranch        *b_reco_hit_amplitude;   //!
   TBranch        *b_reco_hit_time;   //!
   TBranch        *b_reco_hit_plane;   //!
   TBranch        *b_reco_hit_wire;   //!
   TBranch        *b_cluster_start_wire;   //!
   TBranch        *b_cluster_end_wire;   //!
   TBranch        *b_cluster_x;   //!
   TBranch        *b_cluster_z;   //!
   TBranch        *b_cluster_time;   //!
   TBranch        *b_cluster_integral;   //!
   TBranch        *b_cluster_nhits;   //!
   TBranch        *b_cluster_plane;   //!
   TBranch        *b_TotalSimChanCharge_plane0;   //!
   TBranch        *b_TotalSimChanCharge_plane1;   //!
   TBranch        *b_TotalSimChanCharge_plane2;   //!
   TBranch        *b_matchedSimChanCharge_plane0;   //!
   TBranch        *b_matchedSimChanCharge_plane1;   //!
   TBranch        *b_matchedSimChanCharge_plane2;   //!
   TBranch        *b_IDEx;   //!
   TBranch        *b_IDEy;   //!
   TBranch        *b_IDEz;   //!
   TBranch        *b_IDEelectrons;   //!
   TBranch        *b_IDEenergy;   //!
   TBranch        *b_IDEtrackid;   //!

   Event(TTree *tree=0);
   virtual ~Event();
   virtual Int_t    Cut(Long64_t entry);
   virtual Int_t    GetEntry(Long64_t entry);
   virtual Long64_t LoadTree(Long64_t entry);
   virtual void     Init(TTree *tree);
   virtual void     Loop();
   virtual Bool_t   Notify();
   virtual void     Show(Long64_t entry = -1);
};

#endif

#ifdef Event_cxx
Event::Event(TTree *tree) : fChain(0) 
{
// if parameter tree is not specified (or zero), connect the file
// used to generate this class and read the Tree.
   if (tree == 0) {
      TFile *f = (TFile*)gROOT->GetListOfFiles()->FindObject("/pnfs/uboone/scratch/users/ilepetic/bipogrid/v08_00_00_55/ilepetic_newoverlay_bipofinder3/newoverlays_clusters.root");
      if (!f || !f->IsOpen()) {
         f = new TFile("/pnfs/uboone/scratch/users/ilepetic/bipogrid/v08_00_00_55/ilepetic_newoverlay_bipofinder3/newoverlays_clusters.root");
      }
      TDirectory * dir = (TDirectory*)f->Get("/pnfs/uboone/scratch/users/ilepetic/bipogrid/v08_00_00_55/ilepetic_newoverlay_bipofinder3/newoverlays_clusters.root:/decayFinder");
      dir->GetObject("Event",tree);

   }
   Init(tree);
}

Event::~Event()
{
   if (!fChain) return;
   delete fChain->GetCurrentFile();
}

Int_t Event::GetEntry(Long64_t entry)
{
// Read contents of entry.
   if (!fChain) return 0;
   return fChain->GetEntry(entry);
}
Long64_t Event::LoadTree(Long64_t entry)
{
// Set the environment to read one entry
   if (!fChain) return -5;
   Long64_t centry = fChain->LoadTree(entry);
   if (centry < 0) return centry;
   if (fChain->GetTreeNumber() != fCurrent) {
      fCurrent = fChain->GetTreeNumber();
      Notify();
   }
   return centry;
}

void Event::Init(TTree *tree)
{
   // The Init() function is called when the selector needs to initialize
   // a new tree or chain. Typically here the branch addresses and branch
   // pointers of the tree will be set.
   // It is normally not necessary to make changes to the generated
   // code, but the routine can be extended by the user if needed.
   // Init() will be called many times when running on PROOF
   // (once per file to be processed).

   // Set object pointer
   TrackId = 0;
   Mother = 0;
   NumberDaughters = 0;
   pdg = 0;
   Eng = 0;
   StartPointx = 0;
   StartPointy = 0;
   StartPointz = 0;
   EndPointx = 0;
   EndPointy = 0;
   EndPointz = 0;
   TrueWire = 0;
   TrueTime = 0;
   Time = 0;
   Px = 0;
   Py = 0;
   Pz = 0;
   AlphaTruthWire = 0;
   AlphaTruthTime = 0;
   AlphaTruthX = 0;
   AlphaTruthY = 0;
   AlphaTruthZ = 0;
   AlphaTruthIntegral = 0;
   AlphaTruthRMS = 0;
   BetaTruthWire = 0;
   BetaTruthTime = 0;
   BetaTruthX = 0;
   BetaTruthY = 0;
   BetaTruthZ = 0;
   BetaTruthIntegral = 0;
   BetaTruthRMS = 0;
   BetaTruthE = 0;
   BetaTruthEndE = 0;
   process = 0;
   NewNumberHits = 0;
   ClusterPDG = 0;
   ClusterPrimary = 0;
   ClusterHitRMS = 0;
   ClusterHitIntegral = 0;
   ClusterHitGOF = 0;
   ClusterHitTime = 0;
   reco_hit_charge = 0;
   reco_hit_amplitude = 0;
   reco_hit_time = 0;
   reco_hit_plane = 0;
   reco_hit_wire = 0;
   cluster_start_wire = 0;
   cluster_end_wire = 0;
   cluster_x = 0;
   cluster_z = 0;
   cluster_time = 0;
   cluster_integral = 0;
   cluster_nhits = 0;
   cluster_plane = 0;
   IDEx = 0;
   IDEy = 0;
   IDEz = 0;
   IDEelectrons = 0;
   IDEenergy = 0;
   IDEtrackid = 0;
   // Set branch addresses and branch pointers
   if (!tree) return;
   fChain = tree;
   fCurrent = -1;
   fChain->SetMakeClass(1);

   fChain->SetBranchAddress("event", &event, &b_event);
   fChain->SetBranchAddress("run", &run, &b_run);
   fChain->SetBranchAddress("subrun", &subrun, &b_subrun);
   fChain->SetBranchAddress("TrackId", &TrackId, &b_TrackId);
   fChain->SetBranchAddress("Mother", &Mother, &b_Mother);
   fChain->SetBranchAddress("NumberDaughters", &NumberDaughters, &b_NumberDaughters);
   fChain->SetBranchAddress("pdg", &pdg, &b_pdg);
   fChain->SetBranchAddress("Eng", &Eng, &b_Eng);
   fChain->SetBranchAddress("StartPointx", &StartPointx, &b_StartPointx);
   fChain->SetBranchAddress("StartPointy", &StartPointy, &b_StartPointy);
   fChain->SetBranchAddress("StartPointz", &StartPointz, &b_StartPointz);
   fChain->SetBranchAddress("EndPointx", &EndPointx, &b_EndPointx);
   fChain->SetBranchAddress("EndPointy", &EndPointy, &b_EndPointy);
   fChain->SetBranchAddress("EndPointz", &EndPointz, &b_EndPointz);
   fChain->SetBranchAddress("TrueWire", &TrueWire, &b_TrueWire);
   fChain->SetBranchAddress("TrueTime", &TrueTime, &b_TrueTime);
   fChain->SetBranchAddress("Time", &Time, &b_Time);
   fChain->SetBranchAddress("Px", &Px, &b_Px);
   fChain->SetBranchAddress("Py", &Py, &b_Py);
   fChain->SetBranchAddress("Pz", &Pz, &b_Pz);
   fChain->SetBranchAddress("AlphaTruthWire", &AlphaTruthWire, &b_AlphaTruthWire);
   fChain->SetBranchAddress("AlphaTruthTime", &AlphaTruthTime, &b_AlphaTruthTime);
   fChain->SetBranchAddress("AlphaTruthX", &AlphaTruthX, &b_AlphaTruthX);
   fChain->SetBranchAddress("AlphaTruthY", &AlphaTruthY, &b_AlphaTruthY);
   fChain->SetBranchAddress("AlphaTruthZ", &AlphaTruthZ, &b_AlphaTruthZ);
   fChain->SetBranchAddress("AlphaTruthIntegral", &AlphaTruthIntegral, &b_AlphaTruthIntegral);
   fChain->SetBranchAddress("AlphaTruthRMS", &AlphaTruthRMS, &b_AlphaTruthRMS);
   fChain->SetBranchAddress("BetaTruthWire", &BetaTruthWire, &b_BetaTruthWire);
   fChain->SetBranchAddress("BetaTruthTime", &BetaTruthTime, &b_BetaTruthTime);
   fChain->SetBranchAddress("BetaTruthX", &BetaTruthX, &b_BetaTruthX);
   fChain->SetBranchAddress("BetaTruthY", &BetaTruthY, &b_BetaTruthY);
   fChain->SetBranchAddress("BetaTruthZ", &BetaTruthZ, &b_BetaTruthZ);
   fChain->SetBranchAddress("BetaTruthIntegral", &BetaTruthIntegral, &b_BetaTruthIntegral);
   fChain->SetBranchAddress("BetaTruthRMS", &BetaTruthRMS, &b_BetaTruthRMS);
   fChain->SetBranchAddress("BetaTruthE", &BetaTruthE, &b_BetaTruthE);
   fChain->SetBranchAddress("BetaTruthEndE", &BetaTruthEndE, &b_BetaTruthEndE);
   fChain->SetBranchAddress("process", &process, &b_process);
   fChain->SetBranchAddress("NewNumberHits", &NewNumberHits, &b_NewNumberHits);
   fChain->SetBranchAddress("ClusterPDG", &ClusterPDG, &b_ClusterPDG);
   fChain->SetBranchAddress("ClusterPrimary", &ClusterPrimary, &b_ClusterPrimary);
   fChain->SetBranchAddress("ClusterHitRMS", &ClusterHitRMS, &b_ClusterHitRMS);
   fChain->SetBranchAddress("ClusterHitIntegral", &ClusterHitIntegral, &b_ClusterHitIntegral);
   fChain->SetBranchAddress("ClusterHitGOF", &ClusterHitGOF, &b_ClusterHitGOF);
   fChain->SetBranchAddress("ClusterHitTime", &ClusterHitTime, &b_ClusterHitTime);
   fChain->SetBranchAddress("reco_num_hits", &reco_num_hits, &b_reco_num_hits);
   fChain->SetBranchAddress("reco_hit_charge", &reco_hit_charge, &b_reco_hit_charge);
   fChain->SetBranchAddress("reco_hit_amplitude", &reco_hit_amplitude, &b_reco_hit_amplitude);
   fChain->SetBranchAddress("reco_hit_time", &reco_hit_time, &b_reco_hit_time);
   fChain->SetBranchAddress("reco_hit_plane", &reco_hit_plane, &b_reco_hit_plane);
   fChain->SetBranchAddress("reco_hit_wire", &reco_hit_wire, &b_reco_hit_wire);
   fChain->SetBranchAddress("cluster_start_wire", &cluster_start_wire, &b_cluster_start_wire);
   fChain->SetBranchAddress("cluster_end_wire", &cluster_end_wire, &b_cluster_end_wire);
   fChain->SetBranchAddress("cluster_x", &cluster_x, &b_cluster_x);
   fChain->SetBranchAddress("cluster_z", &cluster_z, &b_cluster_z);
   fChain->SetBranchAddress("cluster_time", &cluster_time, &b_cluster_time);
   fChain->SetBranchAddress("cluster_integral", &cluster_integral, &b_cluster_integral);
   fChain->SetBranchAddress("cluster_nhits", &cluster_nhits, &b_cluster_nhits);
   fChain->SetBranchAddress("cluster_plane", &cluster_plane, &b_cluster_plane);
   fChain->SetBranchAddress("TotalSimChanCharge_plane0", &TotalSimChanCharge_plane0, &b_TotalSimChanCharge_plane0);
   fChain->SetBranchAddress("TotalSimChanCharge_plane1", &TotalSimChanCharge_plane1, &b_TotalSimChanCharge_plane1);
   fChain->SetBranchAddress("TotalSimChanCharge_plane2", &TotalSimChanCharge_plane2, &b_TotalSimChanCharge_plane2);
   fChain->SetBranchAddress("matchedSimChanCharge_plane0", &matchedSimChanCharge_plane0, &b_matchedSimChanCharge_plane0);
   fChain->SetBranchAddress("matchedSimChanCharge_plane1", &matchedSimChanCharge_plane1, &b_matchedSimChanCharge_plane1);
   fChain->SetBranchAddress("matchedSimChanCharge_plane2", &matchedSimChanCharge_plane2, &b_matchedSimChanCharge_plane2);
   fChain->SetBranchAddress("IDEx", &IDEx, &b_IDEx);
   fChain->SetBranchAddress("IDEy", &IDEy, &b_IDEy);
   fChain->SetBranchAddress("IDEz", &IDEz, &b_IDEz);
   fChain->SetBranchAddress("IDEelectrons", &IDEelectrons, &b_IDEelectrons);
   fChain->SetBranchAddress("IDEenergy", &IDEenergy, &b_IDEenergy);
   fChain->SetBranchAddress("IDEtrackid", &IDEtrackid, &b_IDEtrackid);
   Notify();
}

Bool_t Event::Notify()
{
   // The Notify() function is called when a new file is opened. This
   // can be either for a new TTree in a TChain or when when a new TTree
   // is started when using PROOF. It is normally not necessary to make changes
   // to the generated code, but the routine can be extended by the
   // user if needed. The return value is currently not used.

   return kTRUE;
}

void Event::Show(Long64_t entry)
{
// Print contents of entry.
// If entry is not specified, print current entry
   if (!fChain) return;
   fChain->Show(entry);
}
Int_t Event::Cut(Long64_t entry)
{
// This function may be called from Loop.
// returns  1 if entry is accepted.
// returns -1 otherwise.
   return 1;
}
#endif // #ifdef Event_cxx
